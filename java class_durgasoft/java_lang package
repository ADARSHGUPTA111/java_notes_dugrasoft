java.lang package

1. Introduction
2. Object Class
3. String class
4. StringBuffer class
5. StringBuilder class
6. Wrapper classes
7. AutoBoxing AutoUnboxing.

------------------------------------
____________________
Introduction
____________________

For writing any java program whether it is simple or complex the most commonly required classes and interfaces are grouped into a separate package which is nothing but java.lang package

we are not required to import java.lang package explicitly because all classes and interfaces present in Lang package by default available to every java program											 ----

__________________
java.lang.Object
__________________

the most commonly required method are defined in a separate class which is nothing but object class for every java class whether it is predefined class or customized class.

Every class in java is child class of object either directly or indirectly so that object class methods by default available to every java class.

Hence Object class is considered as root of all java classes. 

Note : if our class doesn't extend any other class then only our class is the direct child class of object.

e.g class A{

}

A is child of object

if our class extends any other class then our class is indirect child class of object 

e.g 

class A extends B{

}

A is child of Object //invalid

A is child of B and B is child of Object // valid

Conclusion
______________

Either directly or indirectly java won't provide support for multiple inheritance with respect to classes.

Object class defines the following 11 methods 

public String toString();
public native int hashCode();
public boolean equals();
protected native Object clone() throws CloneNotSupportedException
protected void finalize() throws Throwable
public void finalize() throws InterruptedException
public final void wait() throws InterruptedException
public final native void wait(long milliseconds) throws InterruptedException
public final void wait(long milliseconds, int nanoSeconds) throws InterruptedException
public final void notify();
public final void notifyAll();

These are 11 methods present inside object class

Strictly speaking object class contains 12 methods the extra methods is registerNatives(). 

private static native void registerNatives();

this method internally required for object class and not available to the child classes hence we are not required to consider this method 

________________________
1. toString() method
________________________

we can use toString() method to get string representation of an object.

String s = obj.toString();

whenever we are trying to print object reference internally toString() method will be called.

e.g Student s = new Student();

sopln(s); //(sopln(s.toString())) 

if our class doesn't contain toString() method then object class toString() method will be executed.
e.g 
class Student{
	String name;
	int rollNo;
	
	Student(String name, int rollNo){
		this.name = name;
		this.rollNo = rollNo;
	}
	
	public static void main(String[] args){
		Student s1 = new Student("ravi", 101);
		Student s2 = new Student("teja", 102);
		
		sopln(s1);				//Student@6545523
		sopln(s1.toString());			//Student@6545523
		sopln(s2.toString());			//Student@654412
	}
}

In the above example object class toString() method got executed which is implemented as follows

public String toString(){
	return getClass().getName()+"@"+Integer.toHexString(hashCode());
}

classname@hashcode in hexadecimal form.

based on our requirement we can override toString() method to provide our own String representation.

e.g. Whenever we are trying to print student object reference to print his name and roll no we have to override toString() method as follows.

public String toString(){
	return name + "..." + rollNo;
}

return "this is student with name :" + name + " Roll no :" + rollno;

in all wrapper classes, in all collection classes String class, StringBuffer and StringBuilder class toString() method is overridden for meaning full String representation hence it is highly recommended to override toString() method in our class also

e.g

class Test{
	public String toString(){
		return "Test";
	}
	
	public static void main(String[] args){
		String s = new String("Test");
		System.out.println(s);
		Integer i = new Integer(20);
		System.out.println(i);
		ArrayList al = new ArrayList();
		al.add("ravi");
		al.add("shiva");
		System.out.println(al);
		Test t = new Test();
		System.out.println(t);
	}
}

output : 

Test
20
[ravi, shiva]
Test

____________
HashCode()
____________

for every object a unique number generated by JVM which is nothing but hashCode();

hashCode() won't represents address of object. JVM will use hashCode while saving objects into hashing related data structures. Like hash table hash map, hash Set etc. The main advantage of saving objects based on hashCode() is search operation will become easy(the most powerfull search algorithm upto today is hashing.)

if you are giving the chance to object class hashCode() method it will generates hash code based on address of the object. It doesn't mean hashCode() represents address of the object. Based on our requirement we can override hashCode() method in our class. to generates our own hashCode().

overriding hash code method is said to be proper if and only if for every object we have to generate a unique number as hashCode(). 

class Student{
	.
	.
	.
	public int hashCode(){------------>//invalid way or improper way
		return 100;
	}
}

this is improper way of overriding hashCode() method. because for all student objects we are generating same number as hashCode()

class Student{
	.
	.
	.
	public int hashCode(){------------>//valid way or proper way
		return rollNo;
	}
}

This is proper way of overriding hashCode() method because we are generating a different number as hashCode() for every object.

____________________________
toString() vs hashCode()
____________________________

if we are giving chance to object Class toString() method it will internally calls hashCode() method. if we are overriding toString() method then our toString() method may not call hashCode() method.

e.g 1

class Test{
	int i;
	Test(int i){
		this.i = i;
	}
	
	public static void main(String[] args){
		Test t1 = new Test(10);
		Test t2 = new Test(100);
		sopln(t1);
		sopln(t2);
	}
}

output : 

Test@654654
Test@654842


class Test{
	int i;
	Test(int i){
		this.i = i;
	}
	public int hashCode(){
		return i;
	}	
	public static void main(String[] args){
		Test t1 = new Test(10);
		Test t2 = new Test(100);
		sopln(t1);
		sopln(t2);
	}
}

output :

Test@10
Test@100
class Test{
	int i;
	Test(int i){
		this.i = i;
	}
	public int hashCode(){
		return i;
	}	
	
	public String toString(){
		
		return String.valueOf(i);
	}
	public static void main(String[] args){
		Test t1 = new Test(10);
		Test t2 = new Test(100);
		sopln(t1);
		sopln(t2);
	}
}

output : 

10
100

_________________
equals() method
_________________
we can use equals method to check equality of two objects.

e.g obj1.equals(obj2);

if our class doesn't contain equals method then object class equals method will be executed.

class Test{

	String name;
	int rollNo;
	
	Test(String name, int rollno){
		this.name = name;
		this.rollNo = rollno;
	}
	public static void main(String[] args){
		
		Test t1 = new Test("durga",101);
		Test t2 = new Test("ravi",101);
		Test t3 = new Test("durga",101);
		Test t4 = t1;
		
		sopln(t1.equals(t2));
		sopln(t1.equals(t3));
		sopln(t1.equals(t4));
		
	}
}

output:

false
false
true

in the above example object class equals method got executed which is ment for reference compression(address compression) i.e if two references pointing to the same object then only that equals method returns true.

based on our requirement we can override equals() method for content compression.

while overriding equals method for content compression we have to take care about the following.

what is the meaning of equality (i.e whether we have to check only name or only rollNumbers or both).

if we are passing different type of object our equals method should not rise ClassCastException i.e we have to handle ClassCastException to return false.

if we are passing null argument then our equals method should not rise NullPointerException. i.e we have to handle NullPointerException to return false.

The following is a proper way of overriding equals() method for student class content compression.

public boolean equals(Object obj){
	try{
		String name1 = this.name;
		int rollNo1 = this.rollNo;
		
		Student s = (Student) obj;	//RE : ClassCastException
		
		String name2 = s.name();----|----------->//RE : NullPointerException
		int rollno2 = s.rollno;-----|
		
		if(name1.equals(name2) && rollNo1 == rollNo2){
			reurn true;
		}
		return false;
	}catch(ClassCastException e){
		return false;
	}catch(NullPointerException e){
		return false;
	}
}

Student s1 = new Student("durga", 101);
Student s2 = new Student("ravi", 101);
Student s3 = new Student("durga", 101);
Student s4 = s1;

sopln(s1.equals(s2));	//false
sopln(s1.equals(s3));	//true
sopln(s1.equals(s4));	//true

______________________________________
Simplified version of equals() method
______________________________________

public boolean equals(Object obj){
	try{
		
		Student s = (Student) obj;	//RE : ClassCastException
		
		if(this.name.equals(s.name2) && this.rollNo == s.rollNo2){
			reurn true;
		}
		return false;
	}catch(ClassCastException e){
		return false;
	}catch(NullPointerException e){
		return false;
	}
}
___________________________________________
more simplified version of equals() method
___________________________________________

public boolean equals(Object obj){

	if(obj instanceof Student){
		
		Student s = (Student) obj;	//RE : ClassCastException
		
		if(this.name.equals(s.name2) && this.rollNo == s.rollNo2){
			reurn true;
		}
		return false;
	}
	return false;
	
}

Note : to make above equals() method more efficient we have to write the following code at the begging inside equals method

if(obj == this){
	return true;
}

according to this if both references pointing to the same object then without performing any comparison .equals() method returns true directly.



String s1 = new String("Durga");			StringBuffer sb1 = new StringBuffer("Durga");
String s2 = new String("Durga");			StringBuffer sb2 = new StringBuffer("Durga");
  
sopln(s1 == s2);	//false				sopln(sb1 == sb2);	//false
sopln(s1.equals(s2));	//true				sopln(sb1 == sb2);	//false


in String class .equals() method			in StringBuffer .equals() method is not overridden
is overridden for content comparison,			for content comparison hence if objects are equals 
even though objects are different if			.equals() method returns false even though content is same.
content is same then .equals() method
returns true.

__________________
getClass() method
__________________

we can use getClass() method to get run time class definition of an object.

public final Class getClass(); 

by using this 'Class' class object we can access class level properties like fully qualified name of the class. 
Methods information 
Constructors information.
etc.

import java.lang.reflect.Method;

public class Test {
	public static void main(String[] args) {
		int count = 0;
		Object o = new String("Durga");

		Class c = o.getClass();

		System.out.println("Fully Qualified name of class: " + c.getName());
		Method[] m = c.getDeclaredMethods();
		System.out.println("Method information : ");
		for (Method methods : m) {
			System.out.println(methods.getName());
			count++;
		}
		System.out.println("No of methods are : " + count);
	}
}

e.g 2.

To display database vendor specific connection interface implemented class name 

Connection con = DriverManager.getConnection(...);
sopln(con.getClass().getName());

_______
Note : 
_______

After loading every .class file JVM will create an object of the type java.lang.Class in the heap area.

Programmer can use this class object to get class level information.

we can use getClass() method very frequently in reflections.

___________
finalize()
___________

just before destroying an object garbage collector calls finalize method to perform cleanup activities. once finalize method complete automatically garbage collector destroys that object

wait(), notify(), notifyAll()

we can use these methods for inter thread communication 

the thread which is expecting updation, it is responsible to call wait() then immediately the thread enter into waiting state.

The thread which is responsible to perform updation, after performing updation the thread can call notify method.

The waiting thread will get that notification and continue its execution with those updates.


